RUBBER DUCKING

1: A given Object has a set of attributes, each with a name (in the form of an std::string) and a type (identified by an std::type_index stored in the RTTI instance pointed to by the mmoc::Any associated with a given attribute name in a given Object). (This implies "std::unordered_map<std::string,mmoc::Any> attrs;".)
2: A set of defaults will be pushed to a receiving Object from one or more parental Object's immediately above it (which implies that the immediate parents of a given Object need be ordered into a list to enforce consistent default-pushing behaviour). These parental Object's may themselves have further parents from which their attributes are received via pushing. Pushing is the process of assigning attributes in the pushee to the corresponding attributes of the pusher, with "corresponding" being defined by the mapping contained within the PushMap corresponding to the ordered pair of the pushee class/type of Object and the puhser class/type of Object.
3: If an attribute's value wants to be decided by some default pushed from above, it can be .add()'ed while omitting the value argument for convenience and the attribute value will be set to the default constructed value for the corresponding type if it exists, and if not then a redundant value must be manually specified.
4: Various configurations/implementations for a general type/class of Object may sometimes require different sets of attributes which should always share some minimal set of attributes amongst themselves, with said minimal set of attributes identifying the general type/class of Object.
(proposed) An instance of an Object - specifically as opposed to an instance of some C++ class/struct C where C inherits Object - also has its own type/class attached to it; that of a 'pure' Object. Thus, mappings can be defined between pure Object's and other classes/types of Object, which is useful for when you want an Object to act as a provider of defaults for other Object's. (I am doubting design idea as one could easily create a class/type of Object for defaulting purposes, and that way it can play nicely with the provided or other defaulting classes/types of Object, and makes the design less complicated/more minimal and more decentralised. Also, this leaves the possibility for a pure Object to be such that it has no mapping so that it can map "directly" rather than "indirectly through some defined mapping" in terms of attributes, while also leaving the pure Object "impressionless" and thus a good medium for operations on attribute sets, both of which may be useful in some situations. In conclusion, I feel this design idea is poor and I think that the latter option I just described is better in many respects/for many reasons.)
5: In order to avoid the need for inheritance within the scope of Object types/classes, Object's should instead be composed by other Object's, commonly in the form of a list of sub-Object's named "items", but also potentially by being stored in other attributes. The attributes for the Object can then be modified through custom potentially user-defined proxies such that they modify the appropriate attributes in the appropriate way of any/all sub-Object's.
Something to consider: is the ability to get and set attributes through (or not through) mappings all that is needed in terms of polymorphic behaviour? For example, there seems to be a conceptual conflict/disharmony between the idea of mappings and that Object's can be interfaced via any subsection of their full fledged interface. How can this conflict be resolved?
6: A given Object must always have the attributes corresponding with the type/class of the Object such that those can be relied upon as a general interface, thus forming the conception of the Object which is what defines the general type/class of the Object. These general types/classes of Object's correspond to actual C++ classes derived from the Object class which implement (in the sense of enforcing the necessity of) the aforementioned attributes that correspond with the type/class of the Object.
7: A general mechanism to enforce said necessity must be created; one which must also inform the programmer of what was not implemented if the enforcing fails by the way of an exception.

How are proxy attributes pushed down upon? How do they need to be? Is the current design/system sufficient?
(1) Say you have a series of proxy attributes which proxy to some complex object as dynamic interfaces to that object's properties. (Note that the lack of capitalisation in "object" is intentional as we are not talking about Object's but rather objects more generally; instances of C++ classes which may or may not also be Object's.)
A default could be pushed down for what that object should be, but how would it be done? Pushing down onto the attribute for the object will only change the object itself, not all attributes referencing it, unless the act of pushing down the object also changes the references as part of the set function, however that would require a custom set function which may or may not get arbitrarily complex depending on whether the attributes referencing said object are within the same Object as the object, in which case a generalised custom set function could be provided that accepts an std::vector<std::string> for which attributes to change to match, but if not, then another solution could be that the attributes referencing the object do not reference the object itself but rather reference a reference to the object with that reference not changing, which seems that it would be the better solution as no manual checking that references are correct would be needed. So that problem is solved by the current design/system.
(2) What if you wanted to push down set and/or get functions themselves? In theory, you should never do such a thing as it would break the agnosticism of the overall system towards whether a given attribute is owned by the Object or is a proxy to some data that the Object does not own, but is there some case where it would be required?
