RUBBER DUCKING

1: A given Object has a set of attributes, each with a name (in the form of an std::string) and a type (identified by an std::type_index stored in the RTTI instance pointed to by a given mmoc::Any).

2: A set of defaults will be pushed to a recieving Object from one or more parental Object's immediately above it (which implies that the immediate parents of a given Object need be ordered into a list). These parent Object's themselves may have further parents from which their attributes are recieved via pushing.
2.Q: If parent Object's themselves can have parents, how would the defaults be pushed down?

3: Various configurations/implementations for a general type/class of Object may sometimes require different sets of attributes which should always share some minimal set of attributes amongst themselves, with said minimal set of attributes identifying the general type/class of Object.

3.Q: Is there a reasonable situation in which this could not be and indeed was necessarily not the case? (I can't think of one as of the time of writing.)

3.Q2: What about inheritance heirarchies for general types/classes of Object's? What about multiple inheritance? Could these too correspond with inheritance and multiple inheritance of C++ classes?
3.Q2.1: This seems excessive and overcomplicated; avoid this possibility if not actually necessary.
3.Q2.A: I believe they could if the mechanism were such that:
3.Q2.A.1: You can identify all superclasses of a given Object, which is possible using set-like operations on sets of attributes. This is useful for primarily class-specific mappings but also if finding all Object's of a given type/class is ever needed.
3.Q2.A.2: This plays nicely with mappings...
3.Q2.A.2.Q: ...Which raises the question: how would this work in conjunction with class-specific mappings? However it does, I have a feeling it may make 4.Q.2.2 (possibility 1) viable.

4: A given Object, when being pushed to, may not have all of the attributes that are being pushed to due to the incomplete starting state of the Object.
4.1: However, it must always have the attributes corresponding with the type/class of the Object such that those can be relied upon as a general interface, thus forming the conception of the Object which is what defines the general type/class of the Object.
4.2: These general types/classes of Object's correspond to actual C++ classes derived from the Object class which implement (in the sense of enforcing the necessity of) the aforementioned attributes that correspond with the type/class of the Object.
4.2.Q: How is this necessity enforced? A general mechanism to enforce said necessity must be created; one which also must inform the programmer of what was not implemented if the enforcing fails by the way of an exception. This mechanism must additionally play nicely with 3.Q2 if 4.Q.2.2 (possibility 1) is to be viable.


4.Q: A problem then arises; how are the additional attributes not part of the Object's type/class's interface generated?
4.Q.1: They must be generated by the Object pushing defaults as the Object recieving them cannot know the full set of possible defaults as all Object's should be agnostic to anything but their general form/interface/type/class in order to achieve maximal flexibility, extendability, customisability and convenience.
4.Q.2: This implies one of two possibilities:

4.Q.2.1 (possibility 1): That different defaults correspond to different functions being applied to the pushee, with said functions adding and setting the appropriate attributes. This then implies that said functions are stored in the Object which pushes in some form.
4.Q.2.1.Q: In what form, then?
4.Q.2.1.1: Although this method may seem more excessive than possibility 2 at first glance, it does give the ability to alter defaulting behaviour based on the existence or values of attributes, which may be useful. This additional flexibility may even rid the need for inheritance of Object classes/types, which may have the effect of making the overall system simpler, hence being potentially less excessive. (To be investigated further)

4.Q.2.2 (possibility 2): That different defaults correspond to different attributes in the parental Object's with those attributes, when being pushed, 'having the ability' to create new attributes in the child Object if the attributes trying to be pushed to are missing.
4.Q.2.2.X: Is this really viable? Does it become viable in the context of Object class/type-specific mappings? Would inheritance and multiple inheritance for class/type-specific mappings ever actually be required/a necessity?

4.Q2: Another question is if parent Object's themselves can have parents, how would the defaults be pushed down?
4.Q2.1 (posibility 1): The model proposed is that of functions adding and setting the appropriate attributes, but then if a parent of a parent Object does that to a parent Object, that parent Object needs to do the same to its children, but in order to do so it must also somehow recieve said functions so that it may apply them to its children. In this case, I think the defaulting functions should be stored as a static data member of all Object's rather than unnecessarily clogging space in the dynamic sets of attributes of Object's.
4.Q2.2 (possibility 2): [to be filled in]
