RUBBER DUCKING

1: A given Object has a set of attributes, each with a name (in the form of an std::string) and a type (identified by an std::type_index stored in the RTTI instance pointed to by the mmoc::Any associated with a given attribute name). (This implies "std::unordered_map<std::string,mmoc::Any> attrs;".)
2: A set of defaults will be pushed to a recieving Object from one or more parental Object's immediately above it (which implies that the immediate parents of a given Object need be ordered into a list). These parent Object's themselves may have further parents from which their attributes are recieved via pushing. Pushing is the process of assigning attributes in the pushee to the corresponding attributes of the pusher, with "corresponding" being defined by the mapping contained within the PushMap corresponding to the ordered pair of the pushee class/type of Object and the puhser class/type of Object. A given Object, when being pushed to, must have all of the attributes that are being pushed to.
3: If an attribute's value wants to be decided by some default pushed from above, it can be .add()'ed while omitting the value argument and the attribute value will be set to the default constructed value for the corresponding type, if it exists, and if not then a redundant value must be manually specified.
4: Various configurations/implementations for a general type/class of Object may sometimes require different sets of attributes which should always share some minimal set of attributes amongst themselves, with said minimal set of attributes identifying the general type/class of Object. A pure Object's type/class's minimal set of attributes is none. Note that this also means that mappings can be defined between pure Object's and other classes/types of Object.
5: In order to avoid the need for inheritance within Object types/classes, Object's should instead be composed by other Object's, commonly in the form of a list of sub-Object's named "items", but also potentially by being stored in other attributes. The attributes for the Object can then be modified through custom potentially user-defined proxies such that they modify the appropriate attributes in the appropriate way of any/all sub-Object's.
6: A given Object must always have the attributes corresponding with the type/class of the Object such that those can be relied upon as a general interface, thus forming the conception of the Object which is what defines the general type/class of the Object. These general types/classes of Object's correspond to actual C++ classes derived from the Object class which implement (in the sense of enforcing the necessity of) the aforementioned attributes that correspond with the type/class of the Object.
7: A general mechanism to enforce said necessity must be created; one which must also inform the programmer of what was not implemented if the enforcing fails by the way of an exception.
